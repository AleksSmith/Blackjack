# <center>`Учебный проект - игра Blackjack`</center>

![classes](/images/blackjack.jpg)

## Описание игры

Суть проста: раздаются карты, за каждую из которых начисляются очки. Игрок пытается заработать 21 очко, не больше. За каждую карту с числом дается столько очков, сколько на ней указано. За туз — либо 1 очко, либо 11 (что больше подходит игроку), а за валета, даму и короля — по 10 очков.
Компьютер выступает дилером и играет против группы от одного до семи игроков. В начале кона все участники, включая дилера, получают две карты. Игроки могут видеть все свои карты, а также сумму очков. Однако одна из карт дилера скрыта на протяжении всего кона.
Далее каждый игрок может брать дополнительные карты. Если сумма очков у него превысит 21, он проигрывает. Когда все игроки получили возможность набрать дополнительные карты, дилер открывает скрытую карту. Далее он обязан брать новые карты до тех пор, пока сумма его очков не превышает 16. Если у дилера перебор, все игроки, не имеющие перебора, побеждают. В противном случае сумма очков каждого из оставшихся игроков сравнивается с суммой очков дилера. Игрок побеждает, если сумма его очков больше, чем у дилера. В противном случае — проигрывает. Если суммы очков игрока и дилера одинаковы, засчитывается ничья.

## Описание проекта

Разработаем классы, которые будем использовать в нашей программе:

**Класс**|**Родительский класс**|**Описаниe**
-|-|-
***Card***|нет|Карта
***Hand***|нет|Набор карт, коллекция объектов класса ***Card***
***Deck***|***Hand***|Имеет дополнительную функциональность, которая отсутствует в классе ***Hand***, в частности — тасование и раздачу
***GenericPlayer***|***Hand***|Обобщенно описывает игрока. Не является полноценным игроком, а лишь содержит элементы, характерные как для игрока-человека, так и для игрока-компьютера
***Player***|***GenericPlayer***|Человек-игрок
***House***|***GenericPlayer***|Компьютер-игрок
***Game***|нет|Игра

Обратите внимание: класс ***GenericPlayer*** создается для того, чтобы общая функциональность классов ***Player*** и ***House*** не дублировалась в обоих классах.

Колода карт отделена от дилера, поэтому карты колоды будут раздаваться игрокам-людям и игроку-компьютеру на равных. Это значит, что функция-член, предназначенная для раздачи карт, будет полиморфной.

Приведем иерархию данных классов:

![classes](/images/classes.jpg)

Рассмотрим функциональность каждого класса.

**Класс Card**

Член класса|Описание
--|--
***rank m_Rank***|Значение карты (туз, двойка, тройка и так долее). ***rank*** — это перечисление, куда входят все 13 значений
***suit m_Suit***|Масть карты (трефы, бубны, червы и пики). suit — это перечисление, содержащее четыре возможные масти
***bool m_IsFaceUp***|Указывает, как расположена карта — вверх лицом или рубашкой. Влияет на то, отображается она или нет
***int GetValue()***|Возвращает значение карты
***void Flip()***|Переворачивает карту. Может использоваться для того, чтобы перевернуть карту лицом вверх или вниз

**Класс Hand**

Член класса|Описание
--|--
***vector\<Card*\> m_Cards***|Коллекция карт. Хранит указатели на объекты типа ***Сard***
***void Add(Card* pCard)***|Добавляет карту в руку. Добавляет указатель на объект типа ***Сard*** в вектор ***m_Сards***
***void Clear()***|Очищает руку от карт. Удаляет все указатели из вектора ***m_Сards***, устраняя все связанные с ними объекты в куче
***int GetTotal()***|Возвращает сумму очков карт руки

**Класс GenericPlayer**

Член класса|Описание
--|--
***string m_Name***|Имя игрока
***virtual bool IsHitting() const = 0***|Указывает, нужна ли игроку еще одна карта. Чистая виртуальная функция
***bool IsBoosted() const***|Указывает, что у игрока перебор
***void Bust() const***|Объявляет, что у игрока перебор

**Класс Player**

Член класса|Описание
--|--
***virtual bool IsHitting() const***|Указывает, нужна ли игроку еще одна карта
***void Win() const***|Объявляет, что игрок выиграл
***void Lose() const***|Объявляет, что игрок проиграл
***void Push() const***|Объявляет, что игрок сыграл вничью

**Класс House**

Член класса|Описание
--|--
***virtual bool IsHitting() const***|Указывает, нужна ли игроку еще одна карта
***void FlipFirstCard()***|Переворачивает первую карту

**Класс Deck**

Член класса|Описание
--|--
***vold Populate()***|Создает стандартную колоду из 52 карт
***void Shuffle()***|Тасует карты
***vold Deal (Hand& aHand)***|Раздает в руку одну карту
***void AddltionalCards (GenericPlayer& aGenerlcPlayer)***|Раздает игроку дополнительные карты до тех пор, пока он может и хочет их получать

**Класс Game**

Член класса|Описание
--|--
***Deck m_Deck***|Колода карт
***House m_House***|Рука дилера
***vector\<Player\> m_Players***|Группа игроков-людей. Вектор, содержащий объекты типа Player
***void Play()***|Проводит кон игры Blackjack

В функции ***main()*** пользователь должен будет ввести количество игроков и их имена. После этого начнется игровой цикл: создание объекта класса ***Game*** и вызов метода ***play()***. Вот реализация функции ***main()***:

``` cpp
#include <vector>
using namespace std;
int main()
{
    cout << "\t\tWelcome to Blackjack!\n\n";
    
    int numPlayers = 0;
    while (numPlayers < 1 || numPlayers > 7)
    {
        cout << "How many players? (1 - 7): ";
        cin >> numPlayers;
    }
    
    vector<string> names;
    string name;
    for (int i = 0; i < numPlayers; ++i)
    {
        cout << "Enter player name: ";
        cin >> name;
        names.push_back(name);
    }
    cout << endl;
    
    // игровой цикл
    Game aGame(names);
    char again = 'y';
    while (again != 'n' && again != 'N')
    {
        aGame.Play();
        cout << "\nDo you want to play again? (Y/N): ";
        cin >> again;
    }
    
    return 0;
}
```

В функции ***main()*** имена игроков помещаются в вектор, поскольку мы не знаем заранее, сколько человек будет играть. Этот вектор передается в качестве параметра конструктору класса ***Game***.

Cоздадим карту и колоду карт. Предлагаем масти карт и их достоинства оформить в виде перечисления, чтобы легче с ними работать:

```cpp
enum rank {
        ACE = 1, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN,
        JACK, QUEEN, KING
    };
enum suit { CLUBS, DIAMONDS, HEARTS, SPADES };
```

У класса ***Card*** есть метод, который переворачивает карту. В программе это будет реализовано с помощью переменной типа ***bool***, где значению ***false*** соответствует карта, перевернутая рубашкой вверх, а  значению ***true*** — рубашкой вниз.

```cpp
void Card::Flip()
{
    m_IsFaceUp = !(m_IsFaceUp);
}
```
У класса ***Card*** также есть метод, который возвращает значение карты. Но оно доступно только в том случае, когда карта перевернута лицом вверх:

```cpp
int Card::GetValue() const
{
    //если карта перевернута лицом вниз, ее значение равно О
    int value = 0;
    if (m_IsFaceUp)
    {
        // значение - это число, указанное на карте
        value = m_Rank;
        // значение равно 10 для JACK, QUEEN и KING
        if (value > 10)
        {
            value = 10;
        }
    }
    return value;
}
```
Класс ***Card***:

```cpp
class Card
{
public:
    enum rank {
        ACE = 1, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN,
        JACK, QUEEN, KING
    };
    enum suit { CLUBS, DIAMONDS, HEARTS, SPADES };
    
    Card(rank r = ACE, suit s = SPADES, bool ifu = true);
    int GetValue() const;
    void Flip();
    
private:
    rank m_Rank;
    suit m_Suit;
    bool m_IsFaceUp;
};

Card::Card(rank r, suit s, bool ifu) : m_Rank(r), m_Suit(s), m_IsFaceUp(ifu)
{}

int Card::GetValue() const
{
    int value = 0;
    if (m_IsFaceUp)
    {
        value = m_Rank;
        if (value > 10)
        {
            value = 10;
        }
    }
    return value;
}

void Card::Flip()
{
    m_IsFaceUp = !(m_IsFaceUp);
}
```
Теперь займемся классом ***Hand***. Этот класс представляет собой коллекцию карт. Его конструктор резервирует в векторе ***m_Cards*** место в памяти под 7 элементов. Метод ***Add()*** добавляет новую карту в вектор. А метод ***Clear()*** очищает всю память, занятую вектором.

```cpp
class Hand
{
public:
    Hand();
    // виртуальный деструктор
    virtual ~Hand();
    
    // добавляет карту в руку
    void Add(Card* pCard);
    
    // очищает руку от карт
    void Clear();
    
    //получает сумму очков карт в руке, присваивая тузу
    // значение 1 или 11 в зависимости от ситуации
    int GetTotal() const;
    
protected:
    vector<Card*> m_Cards;
};

Hand::Hand()
{
    m_Cards.reserve(7);
}
// деструктор по-прежнему виртуальный
// это уже можно не обозначать
Hand::~Hand()
{
    Clear();
}

void Hand::Add(Card* pCard)
{
    m_Cards.push_back(pCard);
}

void Hand::Clear()
{
    // проходит по вектору, освобождая всю память в куче
    vector<Card*>::iterator iter = m_Cards.begin();
    for (iter = m_Cards.begin(); iter != m_Cards.end(); ++iter)
    {
        delete *iter;
        *iter = 0;
    }
    // очищает вектор указателей
    m_Cards.clear();
}
```
Метод ***Clear()*** удаляет не только все указатели из вектора ***m_Cards***, но и связанные объекты типа ***Card*** и освобождает занятую ими память. Это работает так же, как в реальном мире, когда в конце кона карты сбрасываются. Виртуальный деструктор вызывает этот метод. 
Обратите внимание: хотя деструктор виртуальный, ключевое слово ***virtual*** не используется за пределами класса, а только внутри его определения.

Теперь представим реализацию метода ***GetTotal()***:
```cpp
int Hand::GetTotal() const
{
    // если карт в руке нет, возвращает значение 0
    if (m_Cards.empty())
    {
        return 0;
    }
    
    //если первая карта имеет значение 0, то она лежит рубашкой вверх:
    // вернуть значение 0
    if (m_Cards[0]->GetValue() == 0)
    {
        return 0;
    }
    
    // находит сумму очков всех карт, каждый туз дает 1 очко
    int total = 0;
    vector<Card*>::const_iterator iter;
    for (iter = m_Cards.begin(); iter != m_Cards.end(); ++iter)
    {
        total += (*iter)->GetValue();
    }
    
    // определяет, держит ли рука туз
    bool containsAce = false;
    for (iter = m_Cards.begin(); iter != m_Cards.end(); ++iter)
    {
        if ((*iter)->GetValue() == Card::ACE)
        {
            containsAce = true;
        }
    }
    
    // если рука держит туз и сумма довольно маленькая, туз дает 11 очков
    if (containsAce && total <= 11)
    {
        // добавляем только 10 очков, поскольку мы уже добавили
        // за каждый туз по одному очку
        total += 10;
    }
    
    return total;
}
```
Данный метод возвращает сумму очков для карт в руке. Если рука держит туз, он считается за 1 или 11 очков в зависимости от остальных карт. Количество очков, которое дает туз, определяется так: если в руке есть туз, он дает 11 очков; затем выполняется проверка, превышает ли сумма очков карт в руке число 21. Если нет — количество очков, которое дает туз, не изменяется. В противном случае туз даст 1 очко.